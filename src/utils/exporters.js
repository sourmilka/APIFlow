/**
 * Export Utilities — Multiple export formats for discovered APIs
 * Supports: JSON, CSV, cURL Collection, Postman Collection, HAR
 */

export function exportJSON(session) {
  return JSON.stringify(session, null, 2);
}

export function exportCSV(apis) {
  const headers = ['Method', 'URL', 'Status', 'Response Time (ms)', 'Content Type', 'Authenticated', 'Category', 'Timestamp'];
  const rows = apis.map(api => [
    api.method,
    `"${api.url}"`,
    api.response?.status || '',
    api.response?.responseTime || '',
    api.response?.contentType || api.contentType || '',
    api.authentication ? 'Yes' : 'No',
    api.category || '',
    api.timestamp || ''
  ]);
  return [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
}

export function exportCurlCollection(apis) {
  return apis.map((api, i) => {
    const parts = [`# --- ${i + 1}. ${api.method} ${api.url} ---`, `curl`];
    if (api.method !== 'GET') parts.push(`-X ${api.method}`);
    parts.push(`'${api.url}'`);

    if (api.headers) {
      const skip = ['host', 'connection', 'content-length', 'accept-encoding', 'cache-control', 'sec-ch-ua', 'sec-ch-ua-mobile', 'sec-ch-ua-platform', 'sec-fetch-dest', 'sec-fetch-mode', 'sec-fetch-site', 'upgrade-insecure-requests'];
      Object.entries(api.headers).forEach(([key, value]) => {
        if (!skip.includes(key.toLowerCase())) {
          parts.push(`-H '${key}: ${value}'`);
        }
      });
    }

    if (api.payload) {
      const body = typeof api.payload === 'string' ? api.payload : JSON.stringify(api.payload);
      parts.push(`-d '${body}'`);
    }

    return parts.join(' \\\n  ');
  }).join('\n\n');
}

export function exportPostmanCollection(session) {
  const items = (session.apis || []).map(api => {
    const parsedUrl = new URL(api.url);
    const item = {
      name: `${api.method} ${parsedUrl.pathname}`,
      request: {
        method: api.method,
        header: [],
        url: {
          raw: api.url,
          protocol: parsedUrl.protocol.replace(':', ''),
          host: parsedUrl.hostname.split('.'),
          path: parsedUrl.pathname.split('/').filter(Boolean),
          query: [...parsedUrl.searchParams.entries()].map(([key, value]) => ({ key, value }))
        }
      }
    };

    // Add relevant headers
    if (api.headers) {
      const include = ['authorization', 'content-type', 'accept', 'x-api-key', 'x-auth-token', 'cookie'];
      Object.entries(api.headers).forEach(([key, value]) => {
        if (include.includes(key.toLowerCase())) {
          item.request.header.push({ key, value, type: 'text' });
        }
      });
    }

    // Add body
    if (api.payload) {
      item.request.body = {
        mode: 'raw',
        raw: typeof api.payload === 'string' ? api.payload : JSON.stringify(api.payload, null, 2),
        options: { raw: { language: 'json' } }
      };
    }

    return item;
  });

  // Group by category
  const categories = {};
  items.forEach((item, i) => {
    const cat = session.apis[i]?.category || 'General';
    if (!categories[cat]) categories[cat] = [];
    categories[cat].push(item);
  });

  const folders = Object.entries(categories).map(([name, items]) => ({
    name,
    item: items
  }));

  let hostname = 'website';
  try { hostname = new URL(session.url).hostname; } catch {}

  return JSON.stringify({
    info: {
      name: `APIFlow - ${hostname}`,
      description: `APIs discovered by APIFlow from ${session.url}`,
      schema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json',
      _exporter_id: 'apiflow'
    },
    item: folders.length > 1 ? folders : items,
    variable: [
      { key: 'baseUrl', value: `${new URL(session.url).protocol}//${new URL(session.url).hostname}`, type: 'string' }
    ]
  }, null, 2);
}

export function exportMarkdown(session) {
  let hostname = 'Website';
  try { hostname = new URL(session.url).hostname; } catch {}

  let md = `# API Documentation — ${hostname}\n\n`;
  md += `> Generated by APIFlow on ${new Date().toLocaleDateString()}\n\n`;
  md += `**Source:** ${session.url}\n`;
  md += `**Total APIs:** ${session.apis?.length || 0}\n`;
  md += `**WebSockets:** ${session.webSockets?.length || 0}\n`;
  md += `**Scan Duration:** ${((session.duration || 0) / 1000).toFixed(1)}s\n\n`;
  md += `---\n\n`;

  // Group by category
  const grouped = {};
  (session.apis || []).forEach(api => {
    const cat = api.category || 'General';
    if (!grouped[cat]) grouped[cat] = [];
    grouped[cat].push(api);
  });

  Object.entries(grouped).forEach(([category, apis]) => {
    md += `## ${category}\n\n`;
    apis.forEach(api => {
      md += `### \`${api.method}\` ${api.url}\n\n`;
      if (api.explanations?.length) {
        api.explanations.forEach(exp => { md += `${exp}\n`; });
        md += '\n';
      }
      if (api.response?.status) {
        md += `**Status:** ${api.response.status} ${api.response.statusText || ''}\n`;
      }
      if (api.response?.responseTime) {
        md += `**Response Time:** ${api.response.responseTime}ms\n`;
      }
      if (api.authentication) {
        md += `**Auth:** ${api.authentication.map(a => a.type).join(', ')}\n`;
      }
      md += '\n';
      if (api.response?.data) {
        md += '```json\n' + JSON.stringify(api.response.data, null, 2).substring(0, 1000) + '\n```\n\n';
      }
      md += '---\n\n';
    });
  });

  // WebSockets
  if (session.webSockets?.length > 0) {
    md += `## WebSocket Connections\n\n`;
    session.webSockets.forEach(ws => {
      md += `### ${ws.url}\n\n`;
      md += `**Status:** ${ws.status}\n`;
      md += `**Frames Captured:** ${ws.frames?.length || 0}\n\n`;
      md += '---\n\n';
    });
  }

  return md;
}

export function exportHAR(session) {
  const entries = (session.apis || []).map(api => {
    let parsedUrl;
    try { parsedUrl = new URL(api.url); } catch { parsedUrl = null; }
    return {
      startedDateTime: api.timestamp || new Date().toISOString(),
      time: api.response?.responseTime || 0,
      request: {
        method: api.method,
        url: api.url,
        httpVersion: 'HTTP/1.1',
        cookies: [],
        headers: Object.entries(api.headers || {}).map(([name, value]) => ({ name, value })),
        queryString: parsedUrl ? [...parsedUrl.searchParams.entries()].map(([name, value]) => ({ name, value })) : [],
        postData: api.payload ? { mimeType: api.contentType || 'application/json', text: typeof api.payload === 'string' ? api.payload : JSON.stringify(api.payload) } : undefined,
        headersSize: -1,
        bodySize: api.payload ? JSON.stringify(api.payload).length : 0
      },
      response: {
        status: api.response?.status || 0,
        statusText: api.response?.statusText || '',
        httpVersion: 'HTTP/1.1',
        cookies: [],
        headers: Object.entries(api.response?.headers || {}).map(([name, value]) => ({ name, value })),
        content: {
          size: parseInt(api.response?.size) || 0,
          mimeType: api.response?.contentType || 'application/json',
          text: api.response?.data ? JSON.stringify(api.response.data) : ''
        },
        redirectURL: '',
        headersSize: -1,
        bodySize: parseInt(api.response?.size) || 0
      },
      cache: {},
      timings: { send: 0, wait: api.response?.responseTime || 0, receive: 0 }
    };
  });

  return JSON.stringify({
    log: {
      version: '1.2',
      creator: { name: 'APIFlow', version: '5.0.0' },
      entries
    }
  }, null, 2);
}

export const EXPORT_FORMATS = [
  { id: 'json', name: 'JSON', ext: 'json', mime: 'application/json', fn: (s) => exportJSON(s) },
  { id: 'csv', name: 'CSV', ext: 'csv', mime: 'text/csv', fn: (s) => exportCSV(s.apis || []) },
  { id: 'curl', name: 'cURL Collection', ext: 'sh', mime: 'text/plain', fn: (s) => exportCurlCollection(s.apis || []) },
  { id: 'postman', name: 'Postman Collection', ext: 'json', mime: 'application/json', fn: exportPostmanCollection },
  { id: 'har', name: 'HAR (HTTP Archive)', ext: 'har', mime: 'application/json', fn: exportHAR },
  { id: 'markdown', name: 'Markdown Docs', ext: 'md', mime: 'text/markdown', fn: exportMarkdown },
];

export function downloadFile(content, filename, mimeType = 'application/json') {
  const blob = new Blob([content], { type: mimeType });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
